

# ðŸš€ FastAPI Project Structure (Enhanced Version)

Based on your Node.js backend with descriptive naming conventions, here's the enhanced FastAPI project structure:

## ðŸ“ Enhanced Project Structure

```
fastapi-backend/
â”œâ”€â”€ ðŸ“„ .env.sample
â”œâ”€â”€ ðŸ“„ .gitignore
â”œâ”€â”€ ðŸ“„ requirements.txt
â”œâ”€â”€ ðŸ“„ pyproject.toml
â”œâ”€â”€ ðŸ“„ README.md
â”œâ”€â”€ ðŸ“„ main.py
â”œâ”€â”€ ðŸ“ app/
â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”œâ”€â”€ ðŸ“„ main.py
â”‚   â”œâ”€â”€ ðŸ“„ config.py
â”‚   â”œâ”€â”€ ðŸ“„ constants.py
â”‚   â”œâ”€â”€ ðŸ“ api/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ dependencies.py
â”‚   â”‚   â””â”€â”€ ðŸ“ v1/
â”‚   â”‚       â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚       â”œâ”€â”€ ðŸ“„ api.py
â”‚   â”‚       â””â”€â”€ ðŸ“ routes/
â”‚   â”‚           â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚           â”œâ”€â”€ ðŸ“„ auth.route.py
â”‚   â”‚           â”œâ”€â”€ ðŸ“„ user.route.py
â”‚   â”‚           â”œâ”€â”€ ðŸ“„ video.route.py
â”‚   â”‚           â”œâ”€â”€ ðŸ“„ comment.route.py
â”‚   â”‚           â”œâ”€â”€ ðŸ“„ like.route.py
â”‚   â”‚           â”œâ”€â”€ ðŸ“„ playlist.route.py
â”‚   â”‚           â”œâ”€â”€ ðŸ“„ subscription.route.py
â”‚   â”‚           â””â”€â”€ ðŸ“„ tweet.route.py
â”‚   â”œâ”€â”€ ðŸ“ core/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ config.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ security.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ settings.py
â”‚   â”œâ”€â”€ ðŸ“ db/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ base.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ database.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ session.py
â”‚   â”‚   â””â”€â”€ ðŸ“ migrations/
â”‚   â”‚       â””â”€â”€ ðŸ“„ __init__.py
â”‚   â”œâ”€â”€ ðŸ“ models/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ base.model.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ user.model.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ video.model.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ comment.model.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ like.model.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ playlist.model.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ subscription.model.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ tweet.model.py
â”‚   â”œâ”€â”€ ðŸ“ schemas/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ user.schema.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ video.schema.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ comment.schema.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ like.schema.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ playlist.schema.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ subscription.schema.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ tweet.schema.py
â”‚   â”œâ”€â”€ ðŸ“ controllers/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ user.controller.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ video.controller.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ comment.controller.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ like.controller.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ playlist.controller.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ subscription.controller.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ tweet.controller.py
â”‚   â”œâ”€â”€ ðŸ“ services/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ user.service.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ video.service.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ comment.service.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ like.service.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ playlist.service.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ subscription.service.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ tweet.service.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ auth.service.py
â”‚   â”œâ”€â”€ ðŸ“ middlewares/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ cors.middleware.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ auth.middleware.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ logging.middleware.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ error.middleware.py
â”‚   â””â”€â”€ ðŸ“ utils/
â”‚       â”œâ”€â”€ ðŸ“„ __init__.py
â”‚       â”œâ”€â”€ ðŸ“„ helpers.util.py
â”‚       â”œâ”€â”€ ðŸ“„ validators.util.py
â”‚       â”œâ”€â”€ ðŸ“„ exceptions.util.py
â”‚       â”œâ”€â”€ ðŸ“„ responses.util.py
â”‚       â””â”€â”€ ðŸ“„ constants.util.py
â”œâ”€â”€ ðŸ“ tests/
â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”œâ”€â”€ ðŸ“„ conftest.py
â”‚   â”œâ”€â”€ ðŸ“ api/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_user.route.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_video.route.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ test_auth.route.py
â”‚   â”œâ”€â”€ ðŸ“ controllers/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_user.controller.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ test_video.controller.py
â”‚   â””â”€â”€ ðŸ“ services/
â”‚       â”œâ”€â”€ ðŸ“„ __init__.py
â”‚       â”œâ”€â”€ ðŸ“„ test_user.service.py
â”‚       â””â”€â”€ ðŸ“„ test_video.service.py
â””â”€â”€ ðŸ“ static/
    â”œâ”€â”€ ðŸ“ css/
    â”œâ”€â”€ ðŸ“ js/
    â”œâ”€â”€ ðŸ“ images/
    â””â”€â”€ ðŸ“ uploads/
        â”œâ”€â”€ ðŸ“ videos/
        â”œâ”€â”€ ðŸ“ thumbnails/
        â””â”€â”€ ðŸ“ avatars/
```


## ðŸŽ¯ **Enhanced File Examples**

### **ðŸ“„ app/routes/user.route.py**

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.controllers.user.controller import UserController
from app.schemas.user.schema import UserCreate, UserResponse, UserUpdate
from app.middlewares.auth.middleware import get_current_user

router = APIRouter(prefix="/users", tags=["users"])

@router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """Create a new user account"""
    return await UserController.create_user(db, user)

@router.get("/me", response_model=UserResponse)
async def get_current_user_profile(current_user = Depends(get_current_user)):
    """Get current user profile"""
    return current_user

@router.get("/{user_id}", response_model=UserResponse)
async def get_user_by_id(user_id: int, db: Session = Depends(get_db)):
    """Get user by ID"""
    return await UserController.get_user_by_id(db, user_id)

@router.patch("/me", response_model=UserResponse)
async def update_user_profile(
    user_update: UserUpdate,
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update current user profile"""
    return await UserController.update_user(db, current_user.id, user_update)

@router.delete("/me", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user_account(
    current_user = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete current user account"""
    await UserController.delete_user(db, current_user.id)
```


### **ðŸ“„ app/models/user.model.py**

```python
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.db.base import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    full_name = Column(String(100), nullable=True)
    avatar = Column(String(255), nullable=True)
    cover_image = Column(String(255), nullable=True)
    watch_history = Column(Text, nullable=True)
    password = Column(String(255), nullable=False)
    refresh_token = Column(Text, nullable=True)
    is_active = Column(Boolean, default=True)
    is_verified = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    videos = relationship("Video", back_populates="owner")
    comments = relationship("Comment", back_populates="owner")
    likes = relationship("Like", back_populates="user")
    playlists = relationship("Playlist", back_populates="owner")
    subscriptions_given = relationship("Subscription", foreign_keys="Subscription.subscriber_id", back_populates="subscriber")
    subscriptions_received = relationship("Subscription", foreign_keys="Subscription.channel_id", back_populates="channel")
    tweets = relationship("Tweet", back_populates="owner")
```


### **ðŸ“„ app/models/video.model.py**

```python
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.db.base import Base

class Video(Base):
    __tablename__ = "videos"
    
    id = Column(Integer, primary_key=True, index=True)
    video_file = Column(String(255), nullable=False)
    thumbnail = Column(String(255), nullable=False)
    title = Column(String(200), nullable=False)
    description = Column(Text, nullable=True)
    duration = Column(Integer, nullable=False)  # in seconds
    views = Column(Integer, default=0)
    is_published = Column(Boolean, default=False)
    owner_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    owner = relationship("User", back_populates="videos")
    comments = relationship("Comment", back_populates="video")
    likes = relationship("Like", back_populates="video")
```


### **ðŸ“„ app/controllers/user.controller.py**

```python
from sqlalchemy.orm import Session
from fastapi import HTTPException, status
from app.models.user.model import User
from app.schemas.user.schema import UserCreate, UserUpdate
from app.services.user.service import UserService
from app.utils.responses.util import success_response, error_response

class UserController:
    @staticmethod
    async def create_user(db: Session, user: UserCreate):
        """Create a new user"""
        try:
            # Check if user already exists
            existing_user = await UserService.get_user_by_email(db, user.email)
            if existing_user:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="User with this email already exists"
                )
            
            new_user = await UserService.create_user(db, user)
            return success_response(
                data=new_user,
                message="User created successfully"
            )
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=str(e)
            )
    
    @staticmethod
    async def get_user_by_id(db: Session, user_id: int):
        """Get user by ID"""
        user = await UserService.get_user_by_id(db, user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        return success_response(data=user)
    
    @staticmethod
    async def update_user(db: Session, user_id: int, user_update: UserUpdate):
        """Update user"""
        updated_user = await UserService.update_user(db, user_id, user_update)
        if not updated_user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        return success_response(
            data=updated_user,
            message="User updated successfully"
        )
```


### **ðŸ“„ app/services/user.service.py**

```python
from sqlalchemy.orm import Session
from sqlalchemy import or_
from app.models.user.model import User
from app.schemas.user.schema import UserCreate, UserUpdate
from app.utils.helpers.util import hash_password
from typing import Optional

class UserService:
    @staticmethod
    async def create_user(db: Session, user: UserCreate) -> User:
        """Create a new user"""
        hashed_password = hash_password(user.password)
        db_user = User(
            username=user.username,
            email=user.email,
            full_name=user.full_name,
            password=hashed_password
        )
        db.add(db_user)
        db.commit()
        db.refresh(db_user)
        return db_user
    
    @staticmethod
    async def get_user_by_id(db: Session, user_id: int) -> Optional[User]:
        """Get user by ID"""
        return db.query(User).filter(User.id == user_id).first()
    
    @staticmethod
    async def get_user_by_email(db: Session, email: str) -> Optional[User]:
        """Get user by email"""
        return db.query(User).filter(User.email == email).first()
    
    @staticmethod
    async def get_user_by_username(db: Session, username: str) -> Optional[User]:
        """Get user by username"""
        return db.query(User).filter(User.username == username).first()
    
    @staticmethod
    async def update_user(db: Session, user_id: int, user_update: UserUpdate) -> Optional[User]:
        """Update user"""
        db_user = db.query(User).filter(User.id == user_id).first()
        if not db_user:
            return None
        
        update_data = user_update.dict(exclude_unset=True)
        for field, value in update_data.items():
            setattr(db_user, field, value)
        
        db.commit()
        db.refresh(db_user)
        return db_user
```


### **ðŸ“„ app/schemas/user.schema.py**

```python
from pydantic import BaseModel, EmailStr, validator
from datetime import datetime
from typing import Optional, List

class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: Optional[str] = None

class UserCreate(UserBase):
    password: str
    
    @validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        return v

class UserUpdate(BaseModel):
    username: Optional[str] = None
    email: Optional[EmailStr] = None
    full_name: Optional[str] = None
    avatar: Optional[str] = None
    cover_image: Optional[str] = None

class UserResponse(UserBase):
    id: int
    avatar: Optional[str] = None
    cover_image: Optional[str] = None
    is_active: bool
    is_verified: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True

class UserLogin(BaseModel):
    username: str  # Can be username or email
    password: str
```


## ðŸŽ¨ **Enhanced Naming Conventions**

| Component | Convention | Example |
| :-- | :-- | :-- |
| **Routes** | `{resource}.route.py` | `user.route.py`, `video.route.py` |
| **Models** | `{resource}.model.py` | `user.model.py`, `comment.model.py` |
| **Controllers** | `{resource}.controller.py` | `user.controller.py`, `playlist.controller.py` |
| **Services** | `{resource}.service.py` | `user.service.py`, `subscription.service.py` |
| **Schemas** | `{resource}.schema.py` | `user.schema.py`, `tweet.schema.py` |
| **Middlewares** | `{purpose}.middleware.py` | `auth.middleware.py`, `cors.middleware.py` |
| **Utils** | `{purpose}.util.py` | `helpers.util.py`, `validators.util.py` |
| **Tests** | `test_{resource}.{type}.py` | `test_user.route.py`, `test_video.service.py` |

## ðŸŒŸ **Key Enhancements**

- **ðŸŽ¯ Clear Purpose**: Each file name immediately indicates its function
- **ðŸ“± Social Media Ready**: Complete structure for YouTube/Twitter-like platform
- **ðŸ”„ Consistent**: All naming follows the same `.{type}.py` pattern
- **ðŸ§ª Test Ready**: Organized test structure matching main codebase
- **ðŸ“ Media Support**: Static folders for uploads (videos, thumbnails, avatars)
- **ðŸ”’ Security First**: Dedicated auth middleware and services
- **ðŸ“Š Response Standards**: Consistent response utilities
- **ðŸš€ Scalable**: Easy to add new features following the same pattern
---
# ðŸ—ï¸ FastAPI Module-Functionality Structure

## ðŸ“– Overview

The **Module-Functionality** approach organizes files based on feature domains rather than file types. Each module contains all the components it needs (routes, models, schemas, services) in one cohesive package.

> ðŸ’¡ **Best For**: Monolithic applications with multiple domains and complex business logic

## ðŸŽ¯ Key Benefits

| Benefit | Description |
|---------|-------------|
| ðŸŽ¯ **Domain Focus** | All related functionality grouped together |
| ðŸš€ **Development Efficiency** | Faster feature development and debugging |
| ðŸ” **Better Maintainability** | Easy to locate and modify domain-specific code |
| ðŸ“¦ **Scalability** | Simple to add new modules without affecting others |
| ðŸ‘¥ **Team Collaboration** | Teams can work on different modules independently |

## ðŸ“ Complete Project Structure

```
fastapi-project/
â”œâ”€â”€ ðŸ“ alembic/                    # Database migrations
â”‚   â”œâ”€â”€ ðŸ“„ env.py
â”‚   â”œâ”€â”€ ðŸ“„ script.py.mako
â”‚   â””â”€â”€ ðŸ“ versions/
â”œâ”€â”€ ðŸ“ src/                        # Main application source
â”‚   â”œâ”€â”€ ðŸ“ auth/                   # ðŸ” Authentication Module
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ router.py           # Auth endpoints & routes
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ schemas.py          # Pydantic request/response models
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ models.py           # Database models (User, Token, etc.)
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ service.py          # Business logic (login, register, etc.)
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ dependencies.py     # Auth dependencies & middleware
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ config.py           # Auth-specific configurations
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ constants.py        # Auth constants & error codes
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ exceptions.py       # Auth-specific exceptions
â”‚   â”‚   â””â”€â”€ ðŸ“„ utils.py            # Helper functions (password hashing, etc.)
â”‚   â”œâ”€â”€ ðŸ“ users/                  # ðŸ‘¤ User Management Module
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ router.py           # User CRUD endpoints
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ schemas.py          # User request/response schemas
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ models.py           # User database models
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ service.py          # User business logic
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ dependencies.py     # User-specific dependencies
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ constants.py        # User constants
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ exceptions.py       # User-specific exceptions
â”‚   â”‚   â””â”€â”€ ðŸ“„ utils.py            # User utility functions
â”‚   â”œâ”€â”€ ðŸ“ posts/                  # ðŸ“ Posts Management Module
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ router.py           # Post CRUD endpoints
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ schemas.py          # Post schemas
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ models.py           # Post database models
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ service.py          # Post business logic
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ dependencies.py     # Post dependencies
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ constants.py        # Post constants
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ exceptions.py       # Post exceptions
â”‚   â”‚   â””â”€â”€ ðŸ“„ utils.py            # Post utilities
â”‚   â”œâ”€â”€ ðŸ“ aws/                    # â˜ï¸ AWS Integration Module
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ client.py           # AWS service clients
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ schemas.py          # AWS request/response schemas
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ config.py           # AWS configurations
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ constants.py        # AWS constants
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ exceptions.py       # AWS-specific exceptions
â”‚   â”‚   â””â”€â”€ ðŸ“„ utils.py            # AWS utility functions
â”‚   â”œâ”€â”€ ðŸ“ notifications/          # ðŸ”” Notification Module
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ router.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ schemas.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ models.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ service.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ dependencies.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ constants.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ exceptions.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ utils.py
â”‚   â”œâ”€â”€ ðŸ“„ main.py                 # ðŸš€ FastAPI app initialization
â”‚   â”œâ”€â”€ ðŸ“„ config.py               # ðŸ”§ Global configurations
â”‚   â”œâ”€â”€ ðŸ“„ database.py             # ðŸ—„ï¸ Database connection setup
â”‚   â”œâ”€â”€ ðŸ“„ models.py               # ðŸŒ Global database models
â”‚   â”œâ”€â”€ ðŸ“„ exceptions.py           # ðŸš¨ Global exception handlers
â”‚   â”œâ”€â”€ ðŸ“„ pagination.py           # ðŸ“„ Global pagination utilities
â”‚   â””â”€â”€ ðŸ“„ dependencies.py         # ðŸ”— Global dependencies
â”œâ”€â”€ ðŸ“ tests/                      # ðŸ§ª Test Suite
â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”œâ”€â”€ ðŸ“„ conftest.py
â”‚   â”œâ”€â”€ ðŸ“ auth/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_router.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_service.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ test_utils.py
â”‚   â”œâ”€â”€ ðŸ“ users/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_router.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ test_service.py
â”‚   â”œâ”€â”€ ðŸ“ posts/
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_router.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ test_service.py
â”‚   â””â”€â”€ ðŸ“ aws/
â”‚       â”œâ”€â”€ ðŸ“„ __init__.py
â”‚       â””â”€â”€ ðŸ“„ test_client.py
â”œâ”€â”€ ðŸ“ templates/                  # ðŸŽ¨ Jinja2 templates
â”‚   â”œâ”€â”€ ðŸ“„ base.html
â”‚   â”œâ”€â”€ ðŸ“„ index.html
â”‚   â””â”€â”€ ðŸ“„ login.html
â”œâ”€â”€ ðŸ“ static/                     # ðŸŽ­ Static files
â”‚   â”œâ”€â”€ ðŸ“ css/
â”‚   â”œâ”€â”€ ðŸ“ js/
â”‚   â””â”€â”€ ðŸ“ images/
â”œâ”€â”€ ðŸ“ requirements/               # ðŸ“¦ Dependencies
â”‚   â”œâ”€â”€ ðŸ“„ base.txt                # Base requirements
â”‚   â”œâ”€â”€ ðŸ“„ dev.txt                 # Development requirements
â”‚   â””â”€â”€ ðŸ“„ prod.txt                # Production requirements
â”œâ”€â”€ ðŸ“„ .env                        # ðŸ” Environment variables
â”œâ”€â”€ ðŸ“„ .env.example                # ðŸ“ Environment template
â”œâ”€â”€ ðŸ“„ .gitignore                  # ðŸš« Git ignore rules
â”œâ”€â”€ ðŸ“„ logging.ini                 # ðŸ“Š Logging configuration
â”œâ”€â”€ ðŸ“„ alembic.ini                 # ðŸ—„ï¸ Alembic configuration
â”œâ”€â”€ ðŸ“„ docker-compose.yml          # ðŸ³ Docker configuration
â”œâ”€â”€ ðŸ“„ Dockerfile                  # ðŸ³ Docker image definition
â””â”€â”€ ðŸ“„ README.md                   # ðŸ“– Project documentation
```

## ðŸ—ï¸ Module Architecture

Each module follows a consistent internal structure:

### ðŸ“Š **Module Component Breakdown**

| File | Purpose | Example Content |
|------|---------|-----------------|
| `router.py` | ðŸ›£ï¸ API endpoints and route definitions | `@router.post("/login")` |
| `schemas.py` | ðŸ“‹ Pydantic models for request/response | `class UserCreate(BaseModel)` |
| `models.py` | ðŸ—„ï¸ SQLAlchemy database models | `class User(Base)` |
| `service.py` | ðŸ’¼ Business logic and core functionality | `def authenticate_user()` |
| `dependencies.py` | ðŸ”— FastAPI dependencies and injections | `def get_current_user()` |
| `config.py` | âš™ï¸ Module-specific configurations | `JWT_SECRET_KEY` |
| `constants.py` | ðŸ“ Constants and error codes | `MIN_PASSWORD_LENGTH = 8` |
| `exceptions.py` | âš ï¸ Custom exception classes | `class UserNotFound(HTTPException)` |
| `utils.py` | ðŸ› ï¸ Helper and utility functions | `def hash_password()` |

## ðŸ“ **Implementation Examples**

### **ðŸ“„ src/auth/router.py**
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from src.database import get_db
from src.auth import service, schemas, dependencies

router = APIRouter(prefix="/auth", tags=["authentication"])

@router.post("/login", response_model=schemas.TokenResponse)
async def login(
    credentials: schemas.LoginRequest,
    db: Session = Depends(get_db)
):
    """User login endpoint"""
    user = await service.authenticate_user(db, credentials.username, credentials.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )
    
    token = service.create_access_token(user.id)
    return schemas.TokenResponse(access_token=token, token_type="bearer")

@router.post("/register", response_model=schemas.UserResponse)
async def register(
    user_data: schemas.UserCreate,
    db: Session = Depends(get_db)
):
    """User registration endpoint"""
    return await service.create_user(db, user_data)

@router.get("/me", response_model=schemas.UserResponse)
async def get_current_user_info(
    current_user = Depends(dependencies.get_current_user)
):
    """Get current user information"""
    return current_user
```

### **ðŸ“„ src/auth/service.py**
```python
from sqlalchemy.orm import Session
from passlib.context import CryptContext
from jose import jwt
from datetime import datetime, timedelta
from src.auth import models, schemas, constants, exceptions
from src.auth.config import AUTH_CONFIG

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class AuthService:
    @staticmethod
    async def authenticate_user(db: Session, username: str, password: str):
        """Authenticate user with username and password"""
        user = db.query(models.User).filter(
            models.User.username == username
        ).first()
        
        if not user or not pwd_context.verify(password, user.hashed_password):
            return None
        return user
    
    @staticmethod
    def create_access_token(user_id: int) -> str:
        """Create JWT access token"""
        expire = datetime.utcnow() + timedelta(
            minutes=AUTH_CONFIG.ACCESS_TOKEN_EXPIRE_MINUTES
        )
        
        to_encode = {
            "sub": str(user_id),
            "exp": expire,
            "type": "access"
        }
        
        return jwt.encode(
            to_encode, 
            AUTH_CONFIG.SECRET_KEY, 
            algorithm=AUTH_CONFIG.ALGORITHM
        )
    
    @staticmethod
    async def create_user(db: Session, user_data: schemas.UserCreate):
        """Create new user account"""
        # Check if user exists
        existing_user = db.query(models.User).filter(
            models.User.email == user_data.email
        ).first()
        
        if existing_user:
            raise exceptions.UserAlreadyExists("User with this email already exists")
        
        # Hash password
        hashed_password = pwd_context.hash(user_data.password)
        
        # Create user
        db_user = models.User(
            username=user_data.username,
            email=user_data.email,
            hashed_password=hashed_password
        )
        
        db.add(db_user)
        db.commit()
        db.refresh(db_user)
        
        return db_user
```

### **ðŸ“„ src/auth/schemas.py**
```python
from pydantic import BaseModel, EmailStr, validator
from datetime import datetime
from typing import Optional

class UserBase(BaseModel):
    username: str
    email: EmailStr

class UserCreate(UserBase):
    password: str
    
    @validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters')
        return v

class UserResponse(UserBase):
    id: int
    is_active: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

class LoginRequest(BaseModel):
    username: str
    password: str

class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
```

### **ðŸ“„ src/auth/constants.py**
```python
# Authentication Constants
MIN_PASSWORD_LENGTH = 8
MAX_PASSWORD_LENGTH = 128
USERNAME_MIN_LENGTH = 3
USERNAME_MAX_LENGTH = 50

# Error Codes
class ErrorCodes:
    INVALID_CREDENTIALS = "AUTH_001"
    USER_NOT_FOUND = "AUTH_002"
    USER_ALREADY_EXISTS = "AUTH_003"
    INVALID_TOKEN = "AUTH_004"
    TOKEN_EXPIRED = "AUTH_005"
    INSUFFICIENT_PERMISSIONS = "AUTH_006"

# Token Types
class TokenTypes:
    ACCESS = "access"
    REFRESH = "refresh"
    RESET_PASSWORD = "reset_password"
```

### **ðŸ“„ src/auth/exceptions.py**
```python
from fastapi import HTTPException, status
from src.auth.constants import ErrorCodes

class AuthException(HTTPException):
    """Base authentication exception"""
    pass

class UserNotFound(AuthException):
    def __init__(self, detail: str = "User not found"):
        super().__init__(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=detail,
            headers={"error-code": ErrorCodes.USER_NOT_FOUND}
        )

class UserAlreadyExists(AuthException):
    def __init__(self, detail: str = "User already exists"):
        super().__init__(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=detail,
            headers={"error-code": ErrorCodes.USER_ALREADY_EXISTS}
        )

class InvalidCredentials(AuthException):
    def __init__(self, detail: str = "Invalid credentials"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail,
            headers={"error-code": ErrorCodes.INVALID_CREDENTIALS}
        )

class InvalidToken(AuthException):
    def __init__(self, detail: str = "Invalid token"):
        super().__init__(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail,
            headers={"error-code": ErrorCodes.INVALID_TOKEN}
        )
```

## ðŸ”— **Cross-Module Imports**

When modules need to interact with each other, use explicit imports:

```python
# âœ… Good: Explicit module imports
from src.auth import constants as auth_constants
from src.notifications import service as notification_service
from src.posts.constants import ErrorCode as PostErrorCode
from src.users.models import User

# âŒ Avoid: Ambiguous imports
from constants import ErrorCode  # Which module's constants?
from service import send_email   # Which service?
```

### **ðŸ“„ Example Cross-Module Usage**
```python
# src/posts/service.py
from src.auth import service as auth_service
from src.notifications import service as notification_service
from src.users import models as user_models

class PostService:
    @staticmethod
    async def create_post(db: Session, post_data: schemas.PostCreate, current_user):
        # Create the post
        new_post = models.Post(**post_data.dict(), author_id=current_user.id)
        db.add(new_post)
        db.commit()
        
        # Send notification to followers
        followers = await user_models.get_user_followers(db, current_user.id)
        await notification_service.notify_new_post(followers, new_post)
        
        return new_post
```

## ðŸ“Š **Project Configuration**

### **ðŸ“„ src/main.py**
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from src.auth.router import router as auth_router
from src.users.router import router as users_router
from src.posts.router import router as posts_router
from src.config import settings

app = FastAPI(
    title="Module-Based FastAPI Project",
    description="FastAPI project organized by module functionality",
    version="1.0.0"
)

# Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_HOSTS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(auth_router)
app.include_router(users_router)
app.include_router(posts_router)

@app.get("/")
async def root():
    return {"message": "Welcome to Module-Based FastAPI Project"}
```

## ðŸŒŸ **Advantages of Module-Functionality Structure**

### **âœ… Benefits:**

| Advantage | Description |
|-----------|-------------|
| ðŸŽ¯ **Domain Cohesion** | All related code lives together |
| ðŸš€ **Faster Development** | Easy to locate and modify features |
| ðŸ‘¥ **Team Scalability** | Multiple developers can work on different modules |
| ðŸ”§ **Easy Testing** | Module-specific test isolation |
| ðŸ“¦ **Microservice Ready** | Easy to extract modules into separate services |
| ðŸ”„ **Code Reusability** | Modules can be shared across projects |

### **âš ï¸ Considerations:**

| Challenge | Solution |
|-----------|----------|
| **Code Duplication** | Use global utilities and shared modules |
| **Cross-Module Dependencies** | Use explicit imports and dependency injection |
| **Module Boundaries** | Clear domain separation and well-defined interfaces |

## ðŸŽ¯ **When to Use This Structure**

### **âœ… Perfect For:**
- ðŸ¢ **Large Applications** with multiple business domains
- ðŸ‘¥ **Team Development** with domain-specific teams
- ðŸ”„ **Microservice Migration** planning
- ðŸ“ˆ **Scalable Applications** that will grow significantly

### **âŒ Might Be Overkill For:**
- ðŸ”¸ Simple APIs with few endpoints
- ðŸ”¸ Prototypes or proof-of-concepts
- ðŸ”¸ Single-developer projects
- ðŸ”¸ Applications with minimal business logic

## ðŸš€ **Getting Started**

### **1. Create Module Template**
```bash
mkdir -p src/{auth,users,posts}
for module in auth users posts; do
    touch src/$module/{__init__.py,router.py,schemas.py,models.py,service.py,dependencies.py,config.py,constants.py,exceptions.py,utils.py}
done
```

### **2. Set Up Dependencies**
```bash
pip install fastapi uvicorn sqlalchemy alembic psycopg2-binary
pip install python-jose[cryptography] passlib[bcrypt] python-multipart
```

### **3. Initialize Database**
```bash
alembic init alembic
alembic revision --autogenerate -m "Initial migration"
alembic upgrade head
```
---