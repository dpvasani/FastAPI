# Error Handling 

---


## ğŸ¯ Goal

We'll implement these equivalents:

| Express Component | FastAPI Equivalent                                                                 |
| ----------------- | ---------------------------------------------------------------------------------- |
| `ApiError.js`     | âœ… `api_exceptions.py` (custom exception class)                                     |
| `ApiResponse.js`  | âœ… `api_response.py` (standard response wrapper)                                    |
| `asyncHandler.js` | âœ… FastAPI handles async natively, but we can use `try-except` decorators for reuse |

---

## ğŸ“ Folder Structure (Suggested)

```
app/
â”œâ”€â”€ main.py
â”œâ”€â”€ routes/
â”‚   â””â”€â”€ user.py
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ api_exceptions.py
â”‚   â”œâ”€â”€ api_response.py
â”‚   â””â”€â”€ error_handler.py
```

---

## ğŸ“¦ 1. `api_exceptions.py` (ğŸŒ‹ Equivalent of ApiError.js)

```python
# core/api_exceptions.py

class ApiException(Exception):
    def __init__(self, status_code=500, message="Something went wrong", errors=None):
        self.status_code = status_code
        self.message = message
        self.success = False
        self.errors = errors or []
        super().__init__(self.message)
```

---

## ğŸ“¦ 2. `api_response.py` (ğŸ“¦ Equivalent of ApiResponse.js)

```python
# core/api_response.py

from fastapi.responses import JSONResponse

class ApiResponse:
    def __init__(self, data=None, message="Success", status_code=200):
        self.status_code = status_code
        self.message = message
        self.data = data
        self.success = status_code < 400

    def send(self):
        return JSONResponse(
            status_code=self.status_code,
            content={
                "success": self.success,
                "message": self.message,
                "data": self.data
            }
        )
```

---

## ğŸ§¤ 3. Global Error Handler (ğŸ§¯ Equivalent of Express `.use(errorHandler)`)

```python
# core/error_handler.py

from fastapi import Request
from fastapi.responses import JSONResponse
from core.api_exceptions import ApiException
from fastapi.exceptions import RequestValidationError
from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR

def register_exception_handlers(app):

    @app.exception_handler(ApiException)
    async def api_exception_handler(request: Request, exc: ApiException):
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "success": False,
                "message": exc.message,
                "errors": exc.errors,
                "data": None
            }
        )

    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        return JSONResponse(
            status_code=422,
            content={
                "success": False,
                "message": "Validation Error",
                "errors": exc.errors(),
                "data": None
            }
        )

    @app.exception_handler(Exception)
    async def general_exception_handler(request: Request, exc: Exception):
        return JSONResponse(
            status_code=HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "success": False,
                "message": str(exc),
                "errors": [],
                "data": None
            }
        )
```

---

## âš™ï¸ 4. `main.py` â€“ Tie It All Together

```python
# main.py

from fastapi import FastAPI
from core.error_handler import register_exception_handlers
from routes import user

app = FastAPI()

# Register global exception handlers
register_exception_handlers(app)

# Include routes
app.include_router(user.router)
```

---

## ğŸ§ª 5. Sample Route with Custom Response & Error

```python
# routes/user.py

from fastapi import APIRouter
from core.api_response import ApiResponse
from core.api_exceptions import ApiException

router = APIRouter(
    prefix="/user",
    tags=["User"]
)

@router.get("/profile")
async def get_user():
    # Simulate a condition
    raise ApiException(status_code=404, message="User not found ğŸ•µï¸")

@router.get("/welcome")
async def welcome_user():
    response = ApiResponse(data={"name": "Darshan"}, message="Welcome ğŸ‰")
    return response.send()
```

---

## âœ… Final API Response Examples

### âœ… Success Response

```json
{
  "success": true,
  "message": "Welcome ğŸ‰",
  "data": {
    "name": "Darshan"
  }
}
```

### âŒ Error Response (Custom)

```json
{
  "success": false,
  "message": "User not found ğŸ•µï¸",
  "errors": [],
  "data": null
}
```

---

## âœ… Advantages of This Setup

ğŸ” **Reusable**
ğŸ“¦ **Consistent Response Shape**
ğŸ§¯ **Centralized Error Handling**
ğŸ§ª **Test Friendly & Scalable**
ğŸ’» **Developer-Friendly Debugging**

---

**async/await** natively. Unlike Express.js where you need `asyncHandler()` to catch errors in async functions (since unhandled promise rejections can crash the app), FastAPI's internal engine (Starlette + ASGI) **already handles async errors properly**.

So, technically, you **don't need an `asyncHandler` like in Express**.

---

### âœ… Butâ€¦ What if you want **middleware-like async wrappers**?

You **can** implement a reusable `async_handler` decorator in FastAPI for:

* Logging errors ğŸŒ
* Converting raw exceptions into your custom `ApiException` ğŸš¨
* Centralizing error wrapping across multiple endpoints ğŸ“¦

---

## âš™ï¸ Create `async_handler` Decorator (Optional)

```python
# core/async_handler.py

from functools import wraps
from core.api_exceptions import ApiException

def async_handler(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except ApiException as ae:
            raise ae  # Let FastAPI handle this via your global handler
        except Exception as e:
            # Convert unhandled errors into your custom ApiException
            raise ApiException(status_code=500, message=str(e))
    return wrapper
```

---

## ğŸ§ª Use It in Routes (Optional)

```python
# routes/user.py

from fastapi import APIRouter
from core.api_response import ApiResponse
from core.api_exceptions import ApiException
from core.async_handler import async_handler

router = APIRouter(prefix="/user", tags=["User"])

@router.get("/profile")
@async_handler
async def get_user():
    # Simulating error
    raise ApiException(status_code=404, message="User not found ğŸ’¥")

@router.get("/safe")
@async_handler
async def safe_route():
    # Simulating unknown error
    1 / 0  # This will raise ZeroDivisionError
```

---

## ğŸ”„ Flow with `async_handler`

```
Request âŸ¶ Route Handler âŸ¶ async_handler Decorator
                          â¬‡ï¸
                   Try â†’ Await function
                   Catch â†’ Wrap unknown error in ApiException
                          â¬‡ï¸
                  Global error_handler catches ApiException
```

---

## âœ… Summary

| Use Case                 | Needed in FastAPI?   | How to Implement |
| ------------------------ | -------------------- | ---------------- |
| Catch async route errors | âŒ Handled natively   |                  |
| Uniform error wrapping   | âœ… Optional decorator |                  |
| Centralized error format | âœ… Via global handler |                  |

---

# ğŸ”¥ Custom Exception Handling in FastAPI â€“ Notes & Code

---

## ğŸ“˜ Why Use Custom Exceptions?

* ğŸ§¼ Clean separation of error logic.
* ğŸ§© Encapsulates custom logic and metadata.
* ğŸ§  Easier to debug and maintain.
* ğŸš¦ Enables specific error codes (e.g., `418 I'm a teapot` â˜•).

---

## ğŸ§± Structure of Custom Exception Handling

### âœ… Key Components:

1. **Custom Exception class** â€“ must inherit from `Exception`.
2. **Exception Handler function** â€“ decorated with `@app.exception_handler`.
3. **Registering the handler** â€“ FastAPI will auto-map based on exception type.

---

## ğŸ§ª Example: `StoryException` with Code

```python
# main.py or your router file

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

app = FastAPI()

# ğŸ”¸ 1. Define a custom exception
class StoryException(Exception):
    def __init__(self, name: str):
        self.name = name

# ğŸ”¸ 2. Provide an exception handler
@app.exception_handler(StoryException)
async def story_exception_handler(request: Request, exc: StoryException):
    return JSONResponse(
        status_code=418,  # ğŸ”¥ I'm a teapot (fun status code for demo)
        content={
            "success": False,
            "message": f"Oops! {exc.name} is not allowed in our story. ğŸ“š",
            "data": None
        }
    )

# ğŸ”¸ 3. Route that triggers the custom exception
@app.get("/story/{name}")
async def read_story(name: str):
    if name.lower() == "badwolf":
        raise StoryException(name=name)
    return {"message": f"{name} is a great story character! ğŸ­"}
```

---

## ğŸ’¬ Output Examples

### âœ… Successful Call:

`GET /story/harry`

```json
{
  "message": "harry is a great story character! ğŸ­"
}
```

### âŒ Custom Exception Raised:

`GET /story/badwolf`

```json
{
  "success": false,
  "message": "Oops! badwolf is not allowed in our story. ğŸ“š",
  "data": null
}
```

---

## âœ… Best Practices for Custom Exceptions

| Practice                                | Description                                                           |
| --------------------------------------- | --------------------------------------------------------------------- |
| âœ… Inherit from `Exception`              | Base all your custom exceptions on the built-in class                 |
| âœ… Include helpful attributes            | Like `.name`, `.error_code`, or `.user_id`                            |
| âœ… Use descriptive messages              | Especially in `detail` or `message` field                             |
| ğŸ” Reuse with global exception handler  | Useful for logging, formatting, or localization                       |
| ğŸ” Avoid exposing sensitive information | Donâ€™t return stack traces or internal details in production responses |

---

## ğŸ§© Optional: Raise from Anywhere

You can raise your custom exception in any route, service, or utility:

```python
def validate_story_character(name: str):
    if name.lower() == "badwolf":
        raise StoryException(name)
```

Then in route:

```python
@app.get("/validate/{name}")
def validate(name: str):
    validate_story_character(name)
    return {"msg": "Character is valid!"}
```

---

## ğŸ”„ Summary Flow

```
User Request â Route Function â Raise Custom Exception
                       â¬‡
             Custom Exception Handler (decorated)
                       â¬‡
                JSON Response with status + message
```

---

## ğŸ’¡ Real-World Use Cases

| Exception Name          | Use Case                            |
| ----------------------- | ----------------------------------- |
| `UserNotFoundException` | When user is not found in DB        |
| `TokenExpiredException` | For expired JWTs or session tokens  |
| `PermissionDenied`      | Role-based access control           |
| `PaymentDeclined`       | E-commerce payment error            |
| `StoryException`        | Fun use-case like the example above |

---

## ğŸ§° Need a Custom BaseException Class?

You can even abstract this:

```python
class CustomBaseException(Exception):
    def __init__(self, message: str, status_code: int = 400):
        self.message = message
        self.status_code = status_code
        super().__init__(message)
```
---

# âœ… Unified Custom Exception Handling in FastAPI (Express-Style)

Weâ€™ll combine:

* ğŸ”¥ Your `ApiException` class
* ğŸ¯ Custom exceptions (like `StoryException`)
* ğŸ“¦ Centralized handler
* ğŸ§© Reusable pattern for scalable APIs

---

## ğŸ“ Folder Structure (Recommended)

```
core/
â”œâ”€â”€ api_exceptions.py     # Base exception class (ApiException)
â”œâ”€â”€ custom_exceptions.py  # All your domain-specific custom exceptions
â”œâ”€â”€ error_handler.py      # Global exception handler logic
```

---

## ğŸ”¸ `core/api_exceptions.py` (Base like ApiError.js)

```python
# core/api_exceptions.py

class ApiException(Exception):
    def __init__(self, message: str = "Something went wrong", status_code: int = 500, errors: list = None):
        self.status_code = status_code
        self.message = message
        self.success = False
        self.errors = errors or []
        super().__init__(message)
```

---

## ğŸ”¸ `core/custom_exceptions.py` (Like domain-specific error classes)

```python
# core/custom_exceptions.py

from core.api_exceptions import ApiException

# ğŸ­ Example: Story-specific error
class StoryException(ApiException):
    def __init__(self, name: str):
        super().__init__(
            message=f"Oops! '{name}' is not allowed in our story. ğŸ“š",
            status_code=418,  # I'm a teapot ğŸ˜„
            errors=[f"Invalid character: {name}"]
        )

# ğŸ‘¤ Example: User-specific error
class UserNotFoundException(ApiException):
    def __init__(self, user_id: str):
        super().__init__(
            message=f"User with ID {user_id} not found ğŸš«",
            status_code=404,
            errors=[f"Missing user: {user_id}"]
        )
```

---

## ğŸ”¸ `core/error_handler.py` (Handles all `ApiException` globally)

```python
# core/error_handler.py

from fastapi import Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from core.api_exceptions import ApiException
from starlette.status import HTTP_500_INTERNAL_SERVER_ERROR

def register_exception_handlers(app):

    @app.exception_handler(ApiException)
    async def handle_api_exception(request: Request, exc: ApiException):
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "success": False,
                "message": exc.message,
                "errors": exc.errors,
                "data": None
            }
        )

    @app.exception_handler(RequestValidationError)
    async def handle_validation_error(request: Request, exc: RequestValidationError):
        return JSONResponse(
            status_code=422,
            content={
                "success": False,
                "message": "Validation failed",
                "errors": exc.errors(),
                "data": None
            }
        )

    @app.exception_handler(Exception)
    async def handle_unexpected_error(request: Request, exc: Exception):
        return JSONResponse(
            status_code=HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "success": False,
                "message": "Internal server error",
                "errors": [str(exc)],
                "data": None
            }
        )
```

---

## ğŸ”¸ `main.py` (Register exception handler globally)

```python
# main.py

from fastapi import FastAPI
from core.error_handler import register_exception_handlers
from routes import story

app = FastAPI()

register_exception_handlers(app)  # ğŸ’¥ Plug in your global exception system
app.include_router(story.router)
```

---

## ğŸ”¸ Example Usage: `routes/story.py`

```python
# routes/story.py

from fastapi import APIRouter
from core.custom_exceptions import StoryException

router = APIRouter(prefix="/story", tags=["Story"])

@router.get("/{name}")
async def get_story(name: str):
    if name.lower() == "badwolf":
        raise StoryException(name)
    return {"message": f"{name} is an awesome character! ğŸ­"}
```

---

## ğŸ§ª Sample Response

```json
{
  "success": false,
  "message": "Oops! 'badwolf' is not allowed in our story. ğŸ“š",
  "errors": ["Invalid character: badwolf"],
  "data": null
}
```

---

## ğŸ§  Benefits of This Unified Pattern

âœ… **Express-like developer experience**
âœ… **Reusable error logic with class-based exceptions**
âœ… **Custom status codes and error messages**
âœ… **Plug-and-play across multiple domains (auth, payments, stories, etc.)**
âœ… **Centralized error formatting**

---

## âœ… Bonus: Custom Decorator `@async_handler` (Optional)

You can still wrap your route with this to catch unknown exceptions:

```python
# core/async_handler.py

from functools import wraps
from core.api_exceptions import ApiException

def async_handler(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except ApiException:
            raise  # Let global handler take over
        except Exception as e:
            raise ApiException(message=str(e), status_code=500)
    return wrapper
```

---
