# ğŸš€ Complete FastAPI Setup & GET Methods Guide

## ğŸ¯ Overview

This comprehensive guide covers everything from setting up a FastAPI project to implementing sophisticated GET methods with path parameters, query parameters, and validation. Whether you're a beginner or looking to enhance your FastAPI skills, this guide provides detailed explanations, code examples, and best practices.

## ğŸ› ï¸ **Part 1: Environment Setup & Project Structure**

### ğŸ§ª **1. Virtual Environment Setup (Cross-Platform)**

```bash
# ğŸ“¦ Install virtualenv (if not already installed)
pip install virtualenv

# ğŸ—ï¸ Create virtual environment
virtualenv venv

# âš¡ Activate virtual environment
# Windows ğŸªŸ
venv\Scripts\activate

# macOS/Linux ğŸ§ğŸ
source venv/bin/activate

# âœ… Verify activation (should show (venv) in prompt)
which python  # Should point to venv/bin/python
```

**ğŸ’¡ Pro Tips:**
- Always use virtual environments to avoid dependency conflicts
- Use descriptive names for project-specific environments
- Consider using `python -m venv venv` as an alternative to virtualenv

### ğŸ“¦ **2. Install Core Dependencies**

```bash
# ğŸš€ Install FastAPI and Uvicorn
pip install fastapi uvicorn

# ğŸ”§ Additional useful packages
pip install python-multipart  # For file uploads
pip install python-dotenv     # For environment variables
pip install pydantic[email]    # Enhanced Pydantic validation

# ğŸ’¾ Save dependencies for team collaboration
pip freeze > requirements.txt
```

### ğŸ“ **3. Professional Project Structure**

```
fastapi_project/
â”‚
â”œâ”€â”€ ğŸ“„ main.py                 # Main application entry point
â”œâ”€â”€ ğŸ“„ requirements.txt        # Project dependencies
â”œâ”€â”€ ğŸ“ app/                    # Application package
â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”œâ”€â”€ ğŸ“ routers/           # Route modules
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ items.py
â”‚   â”‚   â””â”€â”€ ğŸ“„ users.py
â”‚   â”œâ”€â”€ ğŸ“ models/            # Pydantic models
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”‚   â””â”€â”€ ğŸ“„ item.py
â”‚   â”œâ”€â”€ ğŸ“ core/              # Core functionality
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”‚   â””â”€â”€ ğŸ“„ config.py
â”‚   â””â”€â”€ ğŸ“ utils/             # Utility functions
â”‚       â”œâ”€â”€ ğŸ“„ __init__.py
â”‚       â””â”€â”€ ğŸ“„ helpers.py
â”œâ”€â”€ ğŸ“ tests/                 # Test modules
â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â””â”€â”€ ğŸ“„ test_main.py
â”œâ”€â”€ ğŸ“ static/                # Static files
â”œâ”€â”€ ğŸ“ templates/             # HTML templates (if needed)
â””â”€â”€ ğŸ“ venv/                  # Virtual environment
```

## ğŸ¯ **Part 2: Core FastAPI Implementation**

### ğŸ”§ **4. Main Application with Advanced Configuration**

```python
# main.py
from fastapi import FastAPI, Query, Path, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from typing import Optional, List
from enum import Enum
import uvicorn

# ğŸ¨ Create FastAPI instance with metadata
app = FastAPI(
    title="ğŸ“š Advanced FastAPI Guide",
    description="ğŸš€ Comprehensive FastAPI implementation with best practices",
    version="1.0.0",
    contact={
        "name": "Your Name",
        "email": "your.email@example.com",
    },
    license_info={
        "name": "MIT",
        "url": "https://opensource.org/licenses/MIT",
    },
)

# ğŸŒ Add CORS middleware for frontend integration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ğŸ”§ Predefined values using Enum for type safety
class ModelName(str, Enum):
    """ğŸ¤– Machine Learning model names with descriptions"""
    alexnet = "alexnet"    # Image classification
    resnet = "resnet"      # Residual networks
    lenet = "lenet"        # Classic CNN architecture
    transformer = "transformer"  # Attention-based models

class Category(str, Enum):
    """ğŸ“¦ Product categories for filtering"""
    electronics = "electronics"
    clothing = "clothing"
    books = "books"
    home_garden = "home_garden"
    sports = "sports"

# ğŸ  Root endpoint with API information
@app.get("/", tags=["ğŸ  Home"])
async def root():
    """
    ğŸ¯ API Welcome endpoint
    
    Returns:
        dict: Welcome message and API information
    """
    return {
        "message": "ğŸš€ Welcome to Advanced FastAPI Guide!",
        "version": "1.0.0",
        "docs_url": "/docs",
        "redoc_url": "/redoc",
        "features": [
            "ğŸ“ Path Parameters with validation",
            "ğŸ” Query Parameters with constraints", 
            "ğŸ¯ Predefined values with Enums",
            "ğŸ“Š Automatic API documentation",
            "ğŸ›¡ï¸ Built-in data validation"
        ]
    }

# ğŸ†” Basic path parameter with type validation
@app.get("/items/{item_id}", tags=["ğŸ“¦ Items"])
async def read_item(
    item_id: int = Path(
        ..., 
        title="Item ID",
        description="ğŸ†” Unique identifier for the item",
        ge=1,  # Greater than or equal to 1
        le=1000  # Less than or equal to 1000
    )
):
    """
    ğŸ“¦ Retrieve item by ID with validation
    
    Args:
        item_id (int): Item identifier (1-1000)
        
    Returns:
        dict: Item information with metadata
        
    Raises:
        HTTPException: If item_id is out of range (handled by Pydantic)
    """
    
    # ğŸ² Simulate item data (replace with database query)
    mock_item = {
        "item_id": item_id,
        "name": f"ğŸ“± Item {item_id}",
        "description": f"ğŸ” This is item number {item_id}",
        "price": item_id * 10.99,
        "in_stock": item_id % 2 == 0,  # Even IDs are in stock
        "created_at": "2024-01-01T00:00:00Z"
    }
    
    return {
        "status": "âœ… success",
        "data": mock_item,
        "meta": {
            "request_id": f"req_{item_id}",
            "api_version": "1.0.0"
        }
    }

# ğŸ¤– Path parameter with predefined values (Enum)
@app.get("/models/{model_name}", tags=["ğŸ¤– AI Models"])
async def get_model(model_name: ModelName):
    """
    ğŸ¤– Get information about AI/ML models
    
    Args:
        model_name (ModelName): Predefined model name from enum
        
    Returns:
        dict: Model information and characteristics
    """
    
    # ğŸ“Š Model metadata database
    model_info = {
        ModelName.alexnet: {
            "description": "ğŸ–¼ï¸ Deep convolutional neural network for image classification",
            "year": 2012,
            "parameters": "60M",
            "accuracy": "84.7%",
            "use_cases": ["Image Recognition", "Computer Vision"]
        },
        ModelName.resnet: {
            "description": "ğŸ”— Residual networks with skip connections",
            "year": 2015,
            "parameters": "25.6M",
            "accuracy": "92.9%",
            "use_cases": ["Image Classification", "Object Detection"]
        },
        ModelName.lenet: {
            "description": "ğŸ›ï¸ Classic CNN architecture for digit recognition",
            "year": 1989,
            "parameters": "431K",
            "accuracy": "98.8%",
            "use_cases": ["Digit Recognition", "Simple Classification"]
        },
        ModelName.transformer: {
            "description": "ğŸ¯ Attention-based model for sequence tasks",
            "year": 2017,
            "parameters": "110M",
            "accuracy": "95.2%",
            "use_cases": ["NLP", "Machine Translation", "Text Generation"]
        }
    }
    
    return {
        "model_name": model_name,
        "info": model_info[model_name],
        "status": "âœ… Model information retrieved successfully"
    }

# ğŸ” Advanced query parameters with validation
@app.get("/products/", tags=["ğŸ›ï¸ Products"])
async def get_products(
    # ğŸ“„ Pagination parameters
    skip: int = Query(
        0, 
        ge=0, 
        title="Skip Items",
        description="ğŸ“Š Number of items to skip for pagination"
    ),
    limit: int = Query(
        10, 
        ge=1, 
        le=100, 
        title="Limit Results",
        description="ğŸ”¢ Maximum number of items to return (1-100)"
    ),
    
    # ğŸ” Search and filter parameters
    search: Optional[str] = Query(
        None,
        min_length=2,
        max_length=50,
        title="Search Query",
        description="ğŸ” Search term for product names or descriptions"
    ),
    
    category: Optional[Category] = Query(
        None,
        title="Product Category",
        description="ğŸ“¦ Filter products by category"
    ),
    
    # ğŸ’° Price filtering
    min_price: Optional[float] = Query(
        None,
        ge=0,
        title="Minimum Price",
        description="ğŸ’° Minimum price filter"
    ),
    max_price: Optional[float] = Query(
        None,
        ge=0,
        title="Maximum Price", 
        description="ğŸ’° Maximum price filter"
    ),
    
    # ğŸ“¦ Stock filtering
    in_stock_only: bool = Query(
        False,
        title="In Stock Only",
        description="ğŸ“¦ Show only products that are in stock"
    ),
    
    # ğŸ“Š Sorting
    sort_by: Optional[str] = Query(
        "name",
        regex="^(name|price|created_at)$",
        title="Sort Field",
        description="ğŸ“Š Sort products by field (name, price, created_at)"
    ),
    
    sort_order: Optional[str] = Query(
        "asc",
        regex="^(asc|desc)$", 
        title="Sort Order",
        description="ğŸ“ˆ Sort order: asc (ascending) or desc (descending)"
    )
):
    """
    ğŸ›ï¸ Advanced product search with filtering, pagination, and sorting
    
    This endpoint demonstrates comprehensive query parameter usage including:
    - ğŸ“„ Pagination (skip, limit)
    - ğŸ” Text search
    - ğŸ“¦ Category filtering  
    - ğŸ’° Price range filtering
    - ğŸ“¦ Stock availability filtering
    - ğŸ“Š Flexible sorting options
    
    Returns:
        dict: Filtered and paginated product results with metadata
    """
    
    # ğŸ² Mock product database (replace with real database queries)
    mock_products = [
        {"id": 1, "name": "ğŸ“± iPhone 15", "category": "electronics", "price": 999.99, "in_stock": True},
        {"id": 2, "name": "ğŸ‘• Cotton T-Shirt", "category": "clothing", "price": 29.99, "in_stock": True},
        {"id": 3, "name": "ğŸ“š Python Programming", "category": "books", "price": 49.99, "in_stock": False},
        {"id": 4, "name": "ğŸ  Garden Hose", "category": "home_garden", "price": 39.99, "in_stock": True},
        {"id": 5, "name": "âš½ Soccer Ball", "category": "sports", "price": 24.99, "in_stock": True},
    ]
    
    # ğŸ” Apply filters (in real app, this would be database queries)
    filtered_products = mock_products
    
    # Category filter
    if category:
        filtered_products = [p for p in filtered_products if p["category"] == category]
    
    # Price filters
    if min_price is not None:
        filtered_products = [p for p in filtered_products if p["price"] >= min_price]
    if max_price is not None:
        filtered_products = [p for p in filtered_products if p["price"]  0
            },
            "filters_applied": {
                "search": search,
                "category": category,
                "min_price": min_price,
                "max_price": max_price,
                "in_stock_only": in_stock_only,
                "sort_by": sort_by,
                "sort_order": sort_order
            }
        },
        "meta": {
            "api_version": "1.0.0",
            "response_time": "45ms"
        }
    }

# ğŸ†” Multiple path parameters with validation
@app.get("/users/{user_id}/orders/{order_id}", tags=["ğŸ‘¤ Users"])
async def get_user_order(
    user_id: int = Path(..., ge=1, title="User ID", description="ğŸ†” User identifier"),
    order_id: int = Path(..., ge=1, title="Order ID", description="ğŸ›’ Order identifier"),
    include_items: bool = Query(False, title="Include Items", description="ğŸ“¦ Include order items in response")
):
    """
    ğŸ‘¤ Get specific order for a user
    
    Args:
        user_id (int): User identifier
        order_id (int): Order identifier  
        include_items (bool): Whether to include order items
        
    Returns:
        dict: Order details with optional items
    """
    
    # ğŸ² Mock order data
    order_data = {
        "order_id": order_id,
        "user_id": user_id,
        "status": "âœ… completed",
        "total": 159.97,
        "created_at": "2024-01-15T10:30:00Z"
    }
    
    if include_items:
        order_data["items"] = [
            {"product_id": 1, "name": "ğŸ“± iPhone Case", "quantity": 2, "price": 24.99},
            {"product_id": 2, "name": "ğŸ”Œ USB Cable", "quantity": 1, "price": 19.99},
            {"product_id": 3, "name": "ğŸ§ Wireless Headphones", "quantity": 1, "price": 89.99}
        ]
    
    return {
        "status": "âœ… success",
        "data": order_data
    }

# ğŸš€ Server startup event
@app.on_event("startup")
async def startup_event():
    """ğŸš€ Application startup tasks"""
    print("ğŸš€ FastAPI application starting up...")
    print("ğŸ“š API Documentation: http://localhost:8000/docs")
    print("ğŸ“‹ ReDoc Documentation: http://localhost:8000/redoc")

# ğŸ›‘ Server shutdown event  
@app.on_event("shutdown")
async def shutdown_event():
    """ğŸ›‘ Application shutdown tasks"""
    print("ğŸ›‘ FastAPI application shutting down...")

# ğŸš€ Run the application
if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,  # Enable auto-reload during development
        log_level="info"
    )
```

## â–¶ï¸ **5. Running the Server**

```bash
# ğŸš€ Start development server with auto-reload
uvicorn main:app --reload

# ğŸŒ Start server on specific host and port
uvicorn main:app --host 0.0.0.0 --port 8000 --reload

# ğŸ”§ Start with custom configuration
uvicorn main:app --reload --log-level debug --access-log

# ğŸ“Š Production server (without reload)
uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4
```

**ğŸ”— Access Points:**
- ğŸ  **Main App**: http://127.0.0.1:8000
- ğŸ“š **Swagger UI**: http://127.0.0.1:8000/docs  
- ğŸ“‹ **ReDoc**: http://127.0.0.1:8000/redoc
- ğŸ“Š **OpenAPI Schema**: http://127.0.0.1:8000/openapi.json

## ğŸ”„ **6. Request Flow Diagrams**

### ğŸ“ **Path Parameter Flow**

```mermaid
flowchart TD
    A[ğŸ‘¤ Client Request: /items/42] --> B[ğŸŒ FastAPI Router]
    B --> C[ğŸ” Extract Path Parameter]
    C --> D[ğŸ“‹ Pydantic Validation]
    D -->|âœ… Valid| E[ğŸ”„ Execute Handler Function]
    D -->|âŒ Invalid| F[âš ï¸ Return 422 Error]
    E --> G[ğŸ“Š Generate Response]
    G --> H[ğŸ“¤ Return JSON Response]
    
    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e8
    style E fill:#e8f5e8
    style G fill:#e8f5e8
    style H fill:#e1f5fe
    style F fill:#ffebee
```

### ğŸ” **Query Parameter Flow**

```mermaid
flowchart TD
    A[ğŸ‘¤ Client Request: /products?skip=0&limit=10&category=electronics] --> B[ğŸŒ FastAPI Router]
    B --> C[ğŸ” Parse Query Parameters]
    C --> D[ğŸ“‹ Validate Each Parameter]
    D -->|âœ… All Valid| E[ğŸ”„ Execute Handler Function]
    D -->|âŒ Any Invalid| F[âš ï¸ Return 422 Error]
    E --> G[ğŸ—ƒï¸ Apply Filters & Pagination]
    G --> H[ğŸ“Š Generate Response]
    H --> I[ğŸ“¤ Return JSON Response]
    
    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e8
    style E fill:#e8f5e8
    style G fill:#e8f5e8
    style H fill:#e8f5e8
    style I fill:#e1f5fe
    style F fill:#ffebee
```

### ğŸ¯ **Enum Validation Flow**

```mermaid
flowchart TD
    A[ğŸ‘¤ Client Request: /models/alexnet] --> B[ğŸŒ FastAPI Router]
    B --> C[ğŸ” Extract Model Name]
    C --> D[ğŸ¯ Check Against Enum Values]
    D -->|âœ… Valid Enum| E[ğŸ”„ Execute Handler Function]
    D -->|âŒ Invalid Enum| F[âš ï¸ Return 422 Error with Valid Options]
    E --> G[ğŸ“Š Retrieve Model Info]
    G --> H[ğŸ“¤ Return Model Details]
    
    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e8
    style E fill:#e8f5e8
    style G fill:#e8f5e8
    style H fill:#e1f5fe
    style F fill:#ffebee
```

## ğŸ§ª **7. Testing Your API**

### ğŸ”§ **Manual Testing Examples**

```bash
# ğŸ†” Test basic path parameter
curl "http://localhost:8000/items/42"

# ğŸ¤– Test enum path parameter
curl "http://localhost:8000/models/alexnet"

# ğŸ” Test query parameters
curl "http://localhost:8000/products/?skip=0&limit=5&category=electronics&in_stock_only=true"

# ğŸ›’ Test multiple path parameters
curl "http://localhost:8000/users/123/orders/456?include_items=true"
```

### ğŸ§ª **Automated Testing with pytest**

```python
# tests/test_main.py
import pytest
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_read_root():
    """ğŸ  Test root endpoint"""
    response = client.get("/")
    assert response.status_code == 200
    data = response.json()
    assert "ğŸš€ Welcome to Advanced FastAPI Guide!" in data["message"]

def test_read_item_valid():
    """ğŸ“¦ Test valid item ID"""
    response = client.get("/items/42")
    assert response.status_code == 200
    data = response.json()
    assert data["data"]["item_id"] == 42

def test_read_item_invalid():
    """âš ï¸ Test invalid item ID"""
    response = client.get("/items/-1")
    assert response.status_code == 422

def test_get_model_valid():
    """ğŸ¤– Test valid model name"""
    response = client.get("/models/alexnet")
    assert response.status_code == 200
    data = response.json()
    assert data["model_name"] == "alexnet"

def test_get_model_invalid():
    """âš ï¸ Test invalid model name"""
    response = client.get("/models/invalid_model")
    assert response.status_code == 422

def test_get_products_with_filters():
    """ğŸ” Test product filtering"""
    response = client.get("/products/?category=electronics&min_price=100&in_stock_only=true")
    assert response.status_code == 200
    data = response.json()
    assert "products" in data["data"]
    assert "pagination" in data["data"]

# ğŸš€ Run tests with: pytest tests/test_main.py -v
```

## ğŸ“Š **8. Complete Feature Comparison**

| Feature | Path Parameters | Enum Parameters | Query Parameters |
|---------|----------------|-----------------|------------------|
| **ğŸ“ Location** | URL path (`/items/{id}`) | URL path (`/models/{name}`) | URL query (`?skip=0&limit=10`) |
| **âœ… Required** | Always required | Always required | Optional by default |
| **ğŸ”§ Validation** | Type hints + Path() | Enum class validation | Type hints + Query() |
| **ğŸ“š Documentation** | Auto-generated in OpenAPI | Dropdown with valid options | Form fields with constraints |
| **ğŸ¯ Use Cases** | Resource identifiers | Predefined choices | Filtering, pagination, search |
| **ğŸ›¡ï¸ Security** | Path traversal protection | Limited to enum values | Input sanitization |
| **âš¡ Performance** | Fast (URL parsing) | Fast (enum lookup) | Moderate (query parsing) |

## ğŸ’¡ **9. Best Practices & Pro Tips**

### ğŸ›¡ï¸ **Security Considerations**

```python
from fastapi import HTTPException, status
import re

@app.get("/secure-items/{item_id}")
async def secure_read_item(
    item_id: int = Path(..., ge=1, le=999999),
    api_key: str = Query(..., min_length=32, max_length=32)
):
    """ğŸ›¡ï¸ Secure endpoint with validation"""
    
    # ğŸ”‘ Validate API key format
    if not re.match(r'^[a-zA-Z0-9]{32}$', api_key):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key format"
        )
    
    # ğŸ” Additional security checks
    if item_id in [666, 999]:  # Blocked IDs
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access to this item is restricted"
        )
    
    return {"item_id": item_id, "status": "âœ… secure access granted"}
```

### âš¡ **Performance Optimization**

```python
from functools import lru_cache
from typing import Dict, Any

@lru_cache(maxsize=100)
def get_cached_model_info(model_name: str) -> Dict[str, Any]:
    """ğŸ’¾ Cache model information for better performance"""
    # Expensive database/API call simulation
    return {"model": model_name, "cached": True}

@app.get("/cached-models/{model_name}")
async def get_cached_model(model_name: ModelName):
    """âš¡ Fast endpoint with caching"""
    return get_cached_model_info(model_name.value)
```

### ğŸ“Š **Response Standardization**

```python
from typing import Generic, TypeVar, Optional
from pydantic import BaseModel

T = TypeVar('T')

class APIResponse(BaseModel, Generic[T]):
    """ğŸ“‹ Standardized API response format"""
    status: str
    message: Optional[str] = None
    data: Optional[T] = None
    meta: Optional[Dict[str, Any]] = None

@app.get("/standardized-items/{item_id}", response_model=APIResponse[Dict])
async def standardized_read_item(item_id: int):
    """ğŸ“Š Endpoint with standardized response"""
    return APIResponse(
        status="success",
        message="Item retrieved successfully",
        data={"item_id": item_id, "name": f"Item {item_id}"},
        meta={"api_version": "1.0.0", "timestamp": "2024-01-01T00:00:00Z"}
    )
```

## ğŸ¯ **10. Summary & Next Steps**

### ğŸ§  **Key Takeaways**

- **ğŸ”§ Setup**: Virtual environments isolate dependencies and prevent conflicts
- **ğŸ“ Path Parameters**: Required, validated, perfect for resource identifiers  
- **ğŸ¯ Enums**: Restrict values to predefined options with automatic validation
- **ğŸ” Query Parameters**: Optional, great for filtering and pagination
- **ğŸ“š Documentation**: FastAPI automatically generates interactive docs
- **ğŸ›¡ï¸ Validation**: Pydantic handles all validation behind the scenes

### ğŸš€ **What's Next?**

1. **ğŸ“ POST/PUT Methods**: Learn request body handling with Pydantic models
2. **ğŸ” Authentication**: Implement OAuth2 and JWT security
3. **ğŸ—ƒï¸ Database Integration**: Connect with SQLAlchemy and async databases
4. **ğŸ§ª Advanced Testing**: Comprehensive test suites with fixtures
5. **ğŸ³ Deployment**: Docker containerization and cloud deployment
6. **ğŸ“Š Monitoring**: Logging, metrics, and health checks

### ğŸ“š **Additional Resources**

- **ğŸ“– Official Docs**: [FastAPI Documentation](https://fastapi.tiangolo.com/)
- **ğŸ¯ Pydantic Guide**: [Pydantic Documentation](https://pydantic-docs.helpmanual.io/)
- **ğŸ§ª Testing Guide**: [FastAPI Testing](https://fastapi.tiangolo.com/tutorial/testing/)
- **ğŸš€ Deployment**: [FastAPI Deployment](https://fastapi.tiangolo.com/deployment/)

